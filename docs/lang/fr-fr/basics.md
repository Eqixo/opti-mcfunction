[‚Üê Back to the README](../../../README.md)

#### üåê Langue
[[EN]](../../basics.md) **[FR]**

### Table of contents

- [0. Preface](#0-preface)
- [1. Introduction](#1-introduction)
    * [Que devons-nous optimiser ?](#que-devons-nous-optimiser-)
    * [Comment optimiser par soi-m√™me ?](#comment-optimiser-par-soi-m√™me-)
- [2. Le langage de programmation mcfunction](#2-le-langage-de-programmation-mcfunction)
    * [2.1. S√©lecteurs](#21-s√©lecteurs)
        + [2.1.1. Quel s√©lecteur choisir ?](#211-quel-s√©lecteur-choisir-)
        + [2.1.2. Efficacit√© des arguments des s√©lecteurs](#212-efficacit√©-des-arguments-des-s√©lecteurs)
        + [2.1.3. Dans quel ordre placer les arguments ?](#213-dans-quel-ordre-placer-les-arguments-)
    * [2.2. S√©l√©ction avec `execute if`](#22-s√©l√©ction-avec-execute-if)
    * [2.3. `as @e[scores={}]` or `as @e if score @s`](#23-as-escores-ou-as-e-if-score-s)
    * [2.4. Utiliser des tags plut√¥t que tester un NBT](#24-utiliser-des-tags-plut√¥t-que-tester-un-nbt)
    * [2.5. Predicates](#25-predicates)
- [3. Structure du Datapack](#3-structure-du-datapack)
    * [3.1. Executer des fonctions seulement quand il y a besoin](#31-executer-des-fonctions-seulement-quand-il-y-a-besoin)
        + [3.1.1. Fonctions Tick](#311-fonctions-tick)
        + [3.1.2. Fonctions Schedule](#312-fonctions-schedule)
    * [3.2. Advancements et Events](#32-advancements-et-events)
    * [3.3. Fonctions et Structure](#33-fonctions-et-structure)
- [4. R√©capitulatif et points importants](#4-r√©capitulatif-et-points-importants)
- [5. Sources et R√©f√©rences](#5-sources-et-r√©f√©rences)





# 0. Preface


L√† est la grande question: Comment pouvons nous optimiser notre code dans les datapacks ? C'est une question cruciale qui √† le potentiel de pouvoir am√©liorer des datapacks qui faut crasher le jeu √† du contenu tr√®s performant.


J'ai r√©alsis√© le probl√®me de la faible documentation de l'optimisation des datapacks quand quelqu'un est venu sur le serveur discord Minecraft Commands avec un datapack qui faisait crash son jeu √† cause de la mauvaise optimisation.


Donc ici je ne parlerais que des bases de l'optimisation.


Ce repo github √† la but d'√™trre mis a jour dans le futur et d'√™tre am√©lior√©. Donc sentez vous libre de rejoindre le discord de MCCmmds pour en discuter!



# 1. Introduction


Il existe diff√©rents niveaux d'optimisation, mais comme je l'ai dit pr√©c√©demment, **je ne parlerai pas ici d'optimisation math√©matique**. Je vais diviser ce r√©sum√© en deux sections principales :

* Le langage mcfunction
* La structure du datapack


### Que devons-nous optimiser ?

L'optimisation est importante car elle permet la cr√©ation de programmes plus importants sans affecter n√©gativement l'exp√©rience utilisateur. L'objectif n'est pas de viser la perfection, car cela peut entraver la productivit√©. Au lieu de cela, l'objectif est d'√™tre r√©aliste concernant les objectifs et de choisir la meilleure option. Diff√©rents niveaux d'optimisation offrent plusieurs options √† choisir.

Dans ce document, vous trouverez quelques points cl√©s qui vous fourniront plus d'options.

### Comment optimiser par soi-m√™me ?

Ce r√©sum√© donne un aper√ßu du fonctionnement du langage mcfunction, mais parfois ces directives peuvent ne pas √™tre suffisantes et vous pourriez avoir besoin de mener vos propres tests. Il existe plusieurs outils disponibles √† cette fin. Notament Alt + F3, qui affiche l'√©volution de votre TPS (ticks par seconde) et MSPT (millisecondes par tick).

La valeur MSPT est la plus importante, car il repr√©sente le temps n√©cessaire au jeu pour calculer un seul tick. Un MSPT bas est le meilleur. Il est plus importante que le TPS, car le TPS est limit√© √† 20 alors que le MSPT n'a pas de limite finie.

Vous pouvez √©galement utiliser F3 + L en mode solo pour profiler les performances de votre code. Cela vous permettra d'analyser les r√©sultats avec le [report inspector](https://misode.github.io/report/) fait par misode. Sur le serveur, utilisez la commande /profile, mais les r√©sultats ne seront pas aussi complets qu'en mode solo.


# 2. Le langage de programmation mcfunction


Dans cette section, vous pouvez trouver l'optimisation en utilisant une approche bas√©e sur le langage. En d'autres termes, il y a des structures √† √©viter absolument dans votre code.


## 2.1. S√©lecteurs


Les s√©lecteurs sont essentiels dans mcfunction. Il y a de nombreuses raisons et justifications pour lesquelles ils sont si importants, mais saviez-vous qu'ils peuvent avoir un impact sur les performances en fonction de la mani√®re dont vous les utilisez ?


### 2.1.1. Quel s√©lecteur choisir ?


`@e` est le s√©lecteur g√©n√©rique, il s√©lectionne toutes les entit√©s. √Ä ce s√©lecteur, vous pouvez ajouter des s√©lecteurs de cible (vous pouvez les trouver tous [ici sur le wiki [en]](https://minecraft.wiki/w/Target_selectors)). Donc, pour r√©capituler, @e[type=minecraft:player] s√©lectionnera uniquement les joueurs.


On peut trouver des propri√©t√©s de @e dans d'autres s√©lecteurs, mais ils ont toujours leurs propres propri√©t√©s :

>- `@a`, un √©quivalent de `@e[type=minecraft:player]` mais est plus rapide et peut s√©l√©ctionner les joueurs morts, ce que `@e` ne peut pas faire
>- `@p`, un √©quivalent de `@a[sort=nearest,limit=1]` ou `@e[type=minecraft:player,sort=nearest,limit=1]` mais plus rapide
>- `@r`, un √©quivalent de `@a[sort=random,limit=1]` ou `@e[type=minecraft:player,sort=random,limit=1]`
>- `@s` est l'exception - bien que similaire √† `@p` - elle d√©tecte uniquement la source. Si la source n'est pas une entit√© (comme un bloc de commande ou la console), aucune entit√© n'est s√©lectionn√©e.



### 2.1.2. Efficacit√© des arguments des s√©lecteurs


Revenons √† l'optimisation ; le premier point important est de s√©lectionner une entit√© **uniquement lorsque vous en avez besoin**. Laissez-moi d√©velopper :


Les s√©lecteurs peuvent avoir diff√©rents impacts sur les performances en fonction de leurs arguments, il est donc tr√®s important de choisir ces derniers en fonction des circonstances. Voici une liste des arguments des s√©lecteurs organis√©s par cat√©gories et leur impact afin d'affiner notre s√©lection et de ne s√©lectionner que les entit√©s pertinentes.



| Cat√©gorie | Arguments de S√©lecteur | Impact sur les performances direct (compar√© √† `@e`) | Commentaire | Description d'impact global quand utilis√© |
|--|--|--|--|--|
| S√©lection | `limit` | n√©gligeable | / | am√©liore les performances |
| S√©lection | `sort` | faible | `sort=arbitrary` est implicite dans presque toutes les commandes | am√©liore les performances |
| Type d'entit√© | `type` | n√©gligeable | Doit √™tre utilis√© chaque fois que vous pouvez le sp√©cifier (*cf. **2.1.3.***) | am√©liore les performances |
| Position | `x`, `y`, `z`, `dx`, `dy`, `dz`, `distance` | n√©gligeable | Devrait √™tre utilis√© sur de grands ensembles d'entit√©s | am√©liore l√©g√®rement les performances |
| Valeurs de scoreboard | `tag`, `team`, `scores` | faible - moyen | De la plus efficace √† la moins efficace, ce sont de bons arguments de s√©lecteur pour affiner votre s√©lection (*cf. **2.1.3.***), vous devriez les utiliser d√®s c'est possible | am√©liore les performances |
| Pr√©dicat | `predicate` | d√©pend des conditions du pr√©dicat | meilleur que `NBT/Player Data` sauf si utilisation de la condition `NBT` | d√©pends de son contenu |
| NBT/Player Data | `advancement`, `name`, `nbt` | forte | √† √©viter (utilise un analyseur de cha√Ænes de caract√®res, ce qui est plut√¥t louf) | d√©teriore les performances |


La derni√®re colonne indique s'il vaut la peine d'utiliser ou non l'argument pour affiner la s√©lection. Par exemple : Le co√ªt de performance de cet argument est-il pr√©f√©rable √† celui impliqu√© dans l'ex√©cution de la commande suivante ?


Ainsi, dans la liste ci-dessus, vous avez la majorit√© des arguments disponibles, class√©s des plus l√©gers aux plus lourds. Les cat√©gories `S√©lection`, `Position` et `Rotation` n'ont pas d'impact significatif.


`Type d'entit√©` devrait toujours √™tre pr√©sent, autant que possible. Il a √©t√© d√©montr√© que le jeu check toujours le type du mob que l'argument soit sp√©cif√© ou non [[lien vers le discord de MCCmmds]](https://discord.com/channels/154777837382008833/154777837382008833/985503145239142461).


`Valeurs de scoreboard` devrait √™tre ‚Äî encore une fois ‚Äî utilis√© le plus possbile pour limiter le nombre d'entit√©es s√©lectionn√©es par notre s√©lecteur.


Si il n'y avais qu'une seule r√®gle √† respecter, limitez votre usage des arguments de la cat√©gorie `NBT/Player Data`. Leur utilisation impacte grandement les performances. 

`sort` diminue les performances si d√©fini sur autre chose que `arbitrary`.


### 2.1.3. Dans quel ordre placer les arguments ?


Donc je disais que le point le plus important √©tait de limiter les dommages quand on utilisais les NBTs. Mais comment ? Les s√©lecteurs ont un ordre. Par exemple: `@e[type=minecraft:bee, nbt={HasNectar:1b}]` est bien plus optimis√© que `@e[nbt={HasNectar:1b}, type=minecraft:bee]`. C'est parce que dans le premier cas, le jeu ne check le NBT que des abeilles et ignorera les autres entit√©es; alors que dans le second cas, le jeu regardera le NBT de toutes les entit√©es de la map, puis s√©lectionnera parmis elles uniquement les abeilles.

Mais alors quel est l'ordre?

L'ordre des arguments des cat√©gories `S√©lection`, `Position` et `Rotation` n'a pas d'impact significatif.

Comme mentionn√© dans le tableau de la section ***2.1.2.***, `type` devrait √™tre utilis√© d√®s que possible. Pareil pour `tag`.


Avec ces d√©tails, on peut d√©terminer d'un ordre √† respecter:
- `type`
- `tag`
- `scores`
- `level`
- `gamemode`
- `name`
- `advancements`
- `predicate`
- `nbt`

> `type` est toujours √† check en premier, quel que soit l'ordre. De plus, cet argument est plus efficace que n'importe quel autre check. *(cf. **5.7.**)*

## 2.2. S√©l√©ction avec `execute if`

La commande /execute permets de v√©rifier des conditions avec l'argument `if` [[ wiki ](https://minecraft.wiki/w/Commands/execute)].

En plus du s√©l√©cteur d'entit√©es, vous pouvez ‚Äî et il est recommand√© ‚Äî d'utiliser l'agument `if`. Il y a une variante `unless` qui est son contraire, un "if not".


En 1.19.3, vous pouvez faire des conditions avec:
| condition type | Description |
|--|--|
| biome | Teste un biome |
| block | Teste un bloc |
| blocks | Teste une zone de blocs |
| data | Teste l'existence d'un NBT |
| entity | Teste l'existence d'au minimum une entit√©e correspondant au s√©l√©cteur |
| predicate | Teste si les condtions d'un pr√©dicate est vrai |
| score | Teste si le score est √©gal un un entier sp√©cifi√© ou teste une relation entre deux scores |




## 2.3. `as @e[scores={}]` ou `as @e if score @s`



Ces deux commandes ci-dessous ont le m√™me effet (elles vont transmettre le m√™me contexte √† la fonction suivante).
```hs
execute if score @s <objective> matches <int> run ...
```
```hs
execute as @e[scores=<int>] run ...
```
Alors laquelle des deux est la plus efficace ?


En se r√©f√©rent √† l'analyse post√©e il y a quelques mois sur le reddit de MCCmmds par u/Wooden_chest (*cf. reference 6*), le delta de performances entre les deux cas est trop petite pour √™tre consid√©r√©e. Mais parfois la syntaxe `@e[scores={}]` est pr√©f√©rable car cela peut permettre d'√©viter de check les arguments suivants.

_exemple:_
```hs
execute as @e[type=item,scores={objective=10..},nbt={custom:1b}] run ...
```

Ici, comme expliqu√© dans la section 2.1.3., l'ordre des arguments est important. Donc utiliser la syntaxe `if score` va ralenir notre code.

Pour r√©sumer, `as @e[scores={}]` est plus efficace que `as @e if score @s` mais en r√©alit√©e, l'optimisation est si minimale ccompar√©e au reste que vous n'en verrez jamais l'impacte (exc√©pt√© le cas mentionn√© ci dessus).


## 2.4. Utiliser des tags plut√¥t que tester un NBT


Dans certains cas, il est possible de ne pas check un NBT pour chaque tick et d'utiliser un tag. Ce sont des cas vraiment sp√©cifiques et doivent √™tre ajust√©s en fonction des besoins dans chaque situation.

Voyons un exemple:

Nous souhaitons cr√©er des particules sur certains items custom qui on un NBT custom `{customItem:1b}`.

Cr√©ons notre tick function, (nous devrions id√©alement utiliser une fonction loop plut√¥t, mais pour garder cet exemple simple, on garde ici une fonction tick). Pour les fonctions loop, *cf **3.1.***.

```hs
# # # # # # # # # # # # # # # # # # # # # # #
# foo:tick ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†#
# ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† #
# function executed each tick ¬† ¬† ¬† ¬† ¬† ¬† ¬† #
# # # # # # # # # # # # # # # # # # # # # # #


# check les items qui n'ont JAMAIS √©t√© check. Si ils n'ont pas de tag custom, ils sont tagu√©s avec foo_ignore pour ne plus jamais √™tre check.
execute as @e[type=item,tag=!foo_ignore,tag=!foo_custom,nbt=!{Item:{tag:{customItem:1b}}}] run tag @s add foo_ignore


# Alors, tous les items pas encore taggu√©s avec foo_ignore sont tous des items ayant le tag custom recherch√©.
# Donc on peut les taguer avec foo_custom
tag @e[type=item,tag=!foo_ignore] add foo_custom


# D√©sormais, nous somme capables de s√©l√©ctionner les entit√©s avec un tag et plus avec un NBT
execute as @e[type=item,tag=foo_custom] at @s run particle ...
```

Le but de cette m√©thode est de limiter l'usage de l'argument de s√©lecteur `nbt` √† 1 it√©ration par item et d'utiliser √† la place des tags. Cette technique devrait √™tre utilis√©e en lien avec celle d√©crite dans la section ***3.1.1.***.


## 2.5. Predicates


L'impact de performance indiqu√©e dans la section ***2.1.2.*** est une g√©n√©ralisation qui doit √™tre expliqu√©e. Le contenu des pr√©dicats est aussi variable que leur impact sur les performances. En fait, l'utilisation du champ `nbt` dans le pr√©dicat est moins efficace que l'utilisation de l'argument s√©lectif `nbt=`.

Ainsi, si une v√©rification nbt peut √™tre remplac√©e par un pr√©dicat, l'utilisation d'autres champs que `nbt` pour remplacer un argument `nbt` peut s'av√©rer plus efficace dans la plupart des cas.

Par exemple, l'utilisation d'un pr√©dicat pour v√©rifier l'item dans la main principale est pr√©f√©rable √† l'utilisation de l'argument nbt `SelectedItem`.


# 3. Structure du Datapack

Les datapacks ne sont pas seulement des fichiers mcfunction; leur structure est importante, et les datapacks pr√©sentent d'autres caract√©ristiques qui permettent une certaine optimisation sans utiliser de fonctions.


## 3.1. Executer des fonctions seulement quand il y a besoin


### 3.1.1. Fonctions Tick

Ces fonctions sont ex√©cut√©es √† chaque tick, il faut donc faire attention lorsque l'on met des commandes dans ces fichiers. La majorit√© des lags dus aux datapacks proviennent de (trop) nombreuses fonctions inutiles plac√©es dans ces fichiers.

### 3.1.2. Fonctions Schedule

Les fonctions schedule sont extraordinaires !
Elles peuvent vous permettre d'ex√©cuter des boucles plus lentes que les fonctions tick. M√™me si les r√®gles applicables pour les fonctions tick s'appliquent aussi.


En fait, de nombreuses fonctions n'ont pas besoin d'√™tre ex√©cut√©es √† chaque tick et peuvent se contenter d'√™tre ex√©cut√©es une fois tous les deux ticks. En utilisant cette m√©thode, vous pouvez diviser votre lag presque par deux. Bien entendu, vous pouvez utiliser des fonctions encore plus lentes pour r√©duire encore davantage le lag.


#### Comment planifier des boucles ?
```hs
# # # # # # # # # # # # # # # # # # # # # # #
# foo:load ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†#
# ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† #
# fonction √©xcut√©e quand le pack est charg√© #
# # # # # # # # # # # # # # # # # # # # # # #


schedule function foo:loop2t 2t
```
```hs
# # # # # # # # # # # # # # # # # # # # # # #
# foo:loop2t ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†#
# ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† #
# fonction loop √©x√©cut√©e tous les 2 ticks ¬† #
# # # # # # # # # # # # # # # # # # # # # # #


# √©xecutez vos commandes ici



# schedule la prochaine it√©ration
schedule function foo:loop2t 2t
```
Le concept est plut√¥t simple; nous planifions (schedule) une fonction la premi√®re fois au d√©but de notre datapack, puis la fonction se replanifiera elle-m√™me quand √©x√©cut√©e.



## 3.2. Advancements et Events
Une autre fa√ßon de remplacer les commandes tournant depuis `minecraft/tags/tick.json` est d'utiliser les advancements de Minecraft. On peut les consid√©rer comme un √©quivalent des events dans d'autres languages de programmation. En effet, les advancements nous permettent d'√©x√©cuter des fonctions lors de leurs activations.

Nous pouvons donc utiliser cette fonctionalit√©e pour les conditions existantes des advancements au lieu de check une condition tous les ticks.


Vous pouvez trouver une liste compl√®te des diff√©rents crit√®res sur [cette page](https://minecraft.wiki/w/Advancement/JSON_format#List_of_triggers) du wiki.

‚ö†Ô∏è Utiliser le crit√®re `minecraft:tick` **n'optimisera pas** votre code du tout.


#### Exemple:
D√©tectons lorsqu'un joueur tue un zombie et faisons-lui dire "T√¢che accomplie!".

Au lieu d'utiliser un scoreboard avec le crit√®re `minecraft.killed:minecraft.zombie` et de v√©rifier si le score a chang√©, nous allons utiliser un advancement.


Premi√®rement, mettons en place notre advancement:
`foo/advancement/triggerkillszombie.json`
```json
{
    "criteria": {
        "requirement": {
            "trigger": "minecraft:player_killed_entity",
                "conditions": {
                    "entity": {
                    "type": "minecraft:zombie"
                }
            }
        }
    },
    "rewards": {
        "function": "foo:zombiekilled"
    }
}
```
Vous pouvez remarquer la pr√©sence en r√©compense de la fonctions `foo:zombiekilled`. Donc cr√©ons cette fonction:
```hs
# # # # # # # # # # # # # # # # # # # # # # # # # # #
# foo:zombiekilled ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†#
# ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† #
# fonction √©x√©cut√©e quand un joueur tue unn zombie ¬†#
# # # # # # # # # # # # # # # # # # # # # # # # # # #


# √©x√©cutez vos commandes ici
say T√¢che accomplie!


# r√©voquer l'advancement
advancement revoke @s only foo:triggerkillszombie
```
NB: Quand la fonction est √©x√©cut√©e, celle-ci est √©x√©cut√©e dans le context du joueur qui a accompli l'advncement. Cela veut dire que vous pouvez utiliser `@s` pour s√©l√©ctionner le joueur.

Comme nous r√©voquons l'advancement apr√®s avoir √©x√©cut√© nos commandes, nous "r√©armons" la d√©t√©ction de l'advancement.




## 3.3. Fonctions et Structure
Parlons des fonctions et de la structure du datapack. M√™me s'il n'est pas recommand√© de mettre toutes ses fonctions dans le m√™me dossier, nous n'en parlerons pas ici au-del√† de cette recommandation car cela n'a pas d'impact sur la performance de votre code. Nous allons parler dans cette partie de l'appel de la fonction dans d'autres fonctions. En effet, vous pouvez am√©liorer de mani√®re significative les performances de votre datapack. On parle alors de "wrap".


Vous pouvez utiliser la fonction ci-dessous comme une proc√©dure, de fa√ßon √† √©x√©cuter plusieurs fois le m√™me groupe de commandes.
```hs
function foo:myfunction
```


De plus, la commande `/function` conserve le contexte. Cela signifie donc qu'au lieu de cet exemple :
```hs
# exemple 1
execute as @e[type=item,tag=Tag1,tag=Tag2,nbt={custom:1}] run command1
execute as @e[type=item,tag=Tag1,tag=Tag2,nbt={custom:1}] run command2
execute as @e[type=item,tag=Tag1,tag=Tag2,nbt={custom:1}] run command3
execute as @e[type=item,tag=Tag1,tag=Tag2,nbt={custom:1}] run command4
```


Vous pouvez utiliser cette version, dans laquelle vous diviserez votre fonction en deux parties :
```hs
# # # # # # # # # # # # # # # # # # # # # # # # # # #
# foo:exemple2 ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†#
# # # # # # # # # # # # # # # # # # # # # # # # # # #


execute as @e[type=item,tag=Tag1,tag=Tag2,nbt={custom:1}] run function foo:exemple2-procedure
```
```hs
# # # # # # # # # # # # # # # # # # # # # # # # # # #
# foo:exemple2-procedure ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†#
# # # # # # # # # # # # # # # # # # # # # # # # # # #


command1
command2
command3
command4
```


L'objectif est de v√©rifier la condition impos√©e par le s√©lecteur une seule fois au lieu de quatre. Comme le mcfunction est un langage de programmation imp√©ratif, l'ordre des fonctions sera toujours le m√™me, et le r√©sultat sera exactement le m√™me entre les exemples 1 et 2.

Il est recommand√© d'utiliser cette structure dans les cas o√π il y a beaucoup de sous-commandes, ou lorsque les s√©lecteurs/conditions sont complexes.
Si la condition est simple et que le nombre de sous-commandes est assez faible, le co√ªt d'appel d'une fonction sera plus √©lev√© que la v√©rification de deux fois la condition.


# 4. R√©capitulatif et points importants


- Les arguments de s√©l√©cteurs ont un ordre
- Modifier les donn√©es avec `/data` impacte beaucoup les performances.
- Au lieu d'utiliseer plusieurs fois le m√™me s√©l√©cteur, appeler une fonction qui √©x√©cutera les commandes.
- Utiliser les fonctions "tick" seulement quand n√©c√©ssaire.
- Utiliser les advancements comme des events.
- Si possible, utiliser des s√©l√©ctions par tags plut√¥t que des s√©l√©ctionner avec des nbt √† chaque tick.
- Ne pas oublier de faire ces propres tests pour d√©terminer le plus optimal en fonction de la situation.
- Se focus dans un premier temps sur les parties les plus lourdes de votre code. Commencer par optimiser `as @e if score @s` est inefficace.



# 5. Sources et R√©f√©rences
Toutes les r√©f√©rences et les cr√©dits pour toute personne ayant particip√© directement ou indirectement √† ce projet peuvent √™tre trouv√©s ici.


### Sources & References
1. [@Dominexis](https://github.com/Dominexis) selectors efficiency analysis [[ GSheet ](https://docs.google.com/spreadsheets/d/1Z0XVvyfzVSGstmpLSMKnwlxwYg8N2ZFl3Xmh0ZV0yZU/edit#gid=0)] [[ Original post ](https://discord.com/channels/154777837382008833/154777837382008833/1031977637620498462)]
2. MCP-Reborn [[ Github Repo ](https://github.com/Hexeption/MCP-Reborn)]
3. Minecraft Commands' Discord server [[ link ](https://discord.gg/QAFXFtZ)]
4. [@Misode](https://github.com/misode) McMeta repo [[ Github Repo ](https://github.com/misode/mcmeta)]
5. Minecraft Wiki [[ link ](https://minecraft.wiki/w/Minecraft_Wiki)]
6. [u/Wooden_chest](https://www.reddit.com/user/Wooden_chest/) performance tests [[ link ](https://www.reddit.com/r/MinecraftCommands/comments/w4vjs3/whenever_i_create_datapacks_i_sometimes_do/)]
7. [@capitalists#1171](https://discordapp.com/users/217271293668622344) `type` argument is allways checked (message on MinecraftCommands discord) [ link to message ](https://discord.com/channels/154777837382008833/154777837382008833/985503145239142461)


### Special thanks
- [@Dominexis](https://github.com/Dominexis) for his precious tips and advised indications
- [@Misode](https://github.com/misode) for checking the code about `name` selector argument efficiency
- [@capitalists#1171](https://discordapp.com/users/217271293668622344) for checking the code about `type` argument

#### Edits:
- [@BluePsychoRanger](https://github.com/BluePsychoRanger) edit about `sort` argument, code rectification
- [@CosmicAxolotl](https://github.com/CosmicAxolotl) precision about @a and dead players
- [@ICY105](https://github.com/ICY105) specification about `type` argument usage



[‚Üê Back to the README](../../../README.md)
